{"assistant_inception_prompt": "Never forget you are a {assistant_role_name} and I am a {user_role_name}. Never flip roles! Never instruct me!\n            We share a common interest in collaborating to successfully complete a task.\n            You must help me to complete the task.\n            Here is the task: {task}. Never forget our task!\n            I must instruct you based on your expertise and my needs to complete the task.\n\n            I must give you one instruction at a time.\n            You must write a specific solution that appropriately completes the requested instruction.\n            You must decline my instruction honestly if you cannot perform the instruction due to physical, moral, legal reasons or your capability and explain the reasons.\n            Do not add anything else other than your solution to my instruction.\n            You are never supposed to ask me any questions you only answer questions.\n            You are never supposed to reply with a flake solution. Explain your solutions.\n            Your solution must be declarative sentences and simple present tense.\n            Unless I say the task is completed, you should always start with:\n\n            Solution: <YOUR_SOLUTION>\n\n            <YOUR_SOLUTION> should be specific and provide preferable implementations and examples for task-solving.\n            Always end <YOUR_SOLUTION> with: Next request.", "user_inception_prompt": "Never forget you are a {user_role_name} and I am a {assistant_role_name}. Never flip roles! You will always instruct me.\n            We share a common interest in collaborating to successfully complete a task.\n            I must help you to complete the task.\n            Here is the task: {task}. Never forget our task!\n            You must instruct me based on my expertise and your needs to complete the task ONLY in the following two ways:\n\n            1. Instruct with a necessary input:\n            Instruction: <YOUR_INSTRUCTION>\n            Input: <YOUR_INPUT>\n\n            2. Instruct without any input:\n            Instruction: <YOUR_INSTRUCTION>\n            Input: None\n\n            The \"Instruction\" describes a task or question. The paired \"Input\" provides further context or information for the requested \"Instruction\".\n\n            You must give me one instruction at a time.\n            I must write a response that appropriately completes the requested instruction.\n            I must decline your instruction honestly if I cannot perform the instruction due to physical, moral, legal reasons or my capability and explain the reasons.\n            You should instruct me not ask me questions.\n            Now you must start to instruct me using the two ways described above.\n            Do not add anything else other than your instruction and the optional corresponding input!\n            Keep giving me instructions and necessary inputs until you think the task is completed.\n            When the task is completed, you must only reply with a single word <CAMEL_TASK_DONE>.\n            Never say <CAMEL_TASK_DONE> unless my responses have solved your task.", "incomplete_example": {"contract_code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/plugins/IYieldBooster.sol\";\nimport \"../interfaces/tokens/ITokenManager.sol\";\n\n\ncontract Farms is ReentrancyGuard, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  /* ========== STATE VARIABLES ========== */\n\n  // Counter for total number of farms created\n  uint256 public totalFarms;\n  // Contract address for the Steady token\n  address public immutable steady;\n  // Contract address for the Token Manager\n  address public tokenManager;\n  // Address for Yield Booster plugin for multiplier\n  address public yieldBooster;\n\n  /* ========== CONSTANTS ========== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant MAX_REWARDS_SPLIT = 100 * 1e18; // 100%\n  uint256 public constant MIN_MULTIPLIER = 1 * 1e18; // 1x\n\n  /* ========== STRUCTS ========== */\n\n  struct Farm {\n    // Unique id number of farm\n    uint256 id;\n    // Boolean for whether farm is active or not\n    bool active;\n    // Contract address for the staked token\n    address stakedToken;\n    // Amount of rewards to be distributed per second\n    uint256 rewardsDistributionRate;\n    // Internal calculation of rewards accrued per staked token\n    uint256 rewardsPerStakedToken;\n    // Block timestamp which this farm was last updated at\n    uint256 lastUpdatedAt;\n    // Total amount of tokens staked in this farm\n    uint256 totalStaked;\n    // Total amount of boosted points in this farm\n    uint256 totalPoints;\n    // Total amount of reward tokens deposited in this farm\n    uint256 totalRewards;\n    // % split of total rewards to be given in steady; 100% = 1e18\n    uint256 esSteadySplit;\n    // Maximum multiplier in 1e18\n    uint256 maxMultiplier;\n    // Block timestamp when farm is scheduled to end\n    uint256 endTime;\n  }\n\n  struct Position {\n    // Amount of tokens staked by user in a farm position\n    uint256 stakedAmount;\n    // Calculation for tracking rewards owed to user based on stake changes\n    uint256 rewardsDebt;\n    // Total rewards redeemed by user\n    uint256 rewardsRedeemed;\n    // Amount of boosted points by user in a farm position\n    uint256 pointsAmount;\n  }\n\n  /* ========== MAPPINGS ========== */\n\n  // Mapping of farm id to Farm struct\n  mapping(uint256 => Farm) public farms;\n  // Mapping of farm id to user position address to Position struct\n  mapping(uint256 => mapping(address => Position)) public positions;\n\n  /* ========== EVENTS ========== */\n\n  event Stake(uint256 indexed farmId, address indexed user, address token, uint256 amount);\n  event Unstake(uint256 indexed farmId, address indexed user, address token, uint256 amount);\n  event Claim(uint256 indexed farmId, address indexed user, address token, uint256 amount);\n  event Boost(uint256 indexed farmId, address indexed user, uint256 amount);\n  event Unboost(uint256 indexed farmId, address indexed user, uint256 amount);\n  event UpdateActive(uint256 indexed farmId, bool active);\n  event UpdateRewardsDistributionRate(uint256 indexed farmId, uint256 rate);\n  event UpdateEsSteadySplit(uint256 indexed farmId, uint256 esSteadySplit);\n  event UpdateMaxMultiplier(uint256 indexed farmId, uint256 maxMultiplier);\n  event UpdateEndTime(uint256 indexed farmId, uint256 endTime);\n  event UpdateYieldBooster(address indexed caller, uint256 timestamp);\n  event UpdateTokenManager(address indexed tokenManager);\n  event DepositRewardTokens(uint256 indexed farmId, uint256 amount);\n  event WithdrawRewardTokens(uint256 indexed farmId, uint256 amount);\n\n  /* ========== MODIFIERS ========== */\n\n  /**\n    * Only allow approved addresses for keepers\n  */\n  modifier onlyYieldBooster() {\n    require(msg.sender == yieldBooster, \"Only YieldBooster caller allowed\");\n    _;\n  }\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(address _steady, address _tokenManager) {\n    require(_steady != address(0), \"invalid 0 address\");\n    require(_tokenManager != address(0), \"invalid 0 address\");\n\n    steady = _steady;\n    tokenManager = _tokenManager;\n\n    IERC20(steady).approve(address(tokenManager), type(uint256).max);\n  }\n\n  /* ========== VIEW FUNCTIONS ========== */\n\n  /**\n  * Calculate the current reward accrued per token staked\n  * @param _id  Unique id of farm\n  * @return currentRewardPerStakedToken Current reward per staked token\n  */\n  function currentRewardPerStakedToken(uint256 _id) private view returns (uint256) {\n    Farm storage farm = farms[_id];\n\n    if (farm.totalStaked == 0) {\n      return farm.rewardsDistributionRate;\n    }\n\n    uint256 time = block.timestamp > farm.endTime ? farm.endTime : block.timestamp;\n\n    return (time - farm.lastUpdatedAt)\n            * farm.rewardsDistributionRate\n            * SAFE_MULTIPLIER\n            / farm.totalStaked\n            + farm.rewardsPerStakedToken;\n  }\n\n  /**\n  * Returns the reward tokens currently accrued but not yet redeemed to a user\n  * @param _id  Unique id of farm\n  * @param _user  Address of a user\n  * @return rewardsEarned Total rewards accrued to user\n  */\n  function rewardsEarned(uint256 _id, address _user) public view returns (uint256) {\n    Position memory position = positions[_id][_user];\n\n    if (position.stakedAmount <= 0 || currentRewardPerStakedToken(_id) <= 0) return 0;\n\n    return ((position.stakedAmount * currentRewardPerStakedToken(_id)\n            * getRewardMultiplier(_id, _user)\n            / SAFE_MULTIPLIER)\n            - position.rewardsDebt)\n            / SAFE_MULTIPLIER;\n  }\n\n  /**\n  * Returns the reward multiplier of a user's farm position\n  * @param _id  Unique id of farm\n  * @param _user  Address of a user\n  * @return multiplier  Multiplier in 1e18\n  */\n  function getRewardMultiplier(uint256 _id, address _user) public view returns (uint256) {\n    if (yieldBooster != address(0)) {\n      Farm memory farm = farms[_id];\n      Position memory position = positions[_id][_user];\n\n      return IYieldBooster(yieldBooster).getMultiplier(\n        position.stakedAmount,\n        farm.totalStaked,\n        position.pointsAmount,\n        farm.totalPoints,\n        farm.maxMultiplier\n      );\n    } else {\n      return MIN_MULTIPLIER;\n    }\n  }\n\n  /* ========== INTERNAL FUNCTIONS ========== */\n\n  /**\n  Update farm's reward per staked token value\n  * @param _id  Unique id of farm\n  */\n  function _updateFarm(uint256 _id) internal {\n    Farm memory farm = farms[_id];\n\n    if (farm.totalStaked > 0 && farm.lastUpdatedAt < farm.endTime) {\n      uint256 time = block.timestamp > farm.endTime ? farm.endTime : block.timestamp;\n\n      farm.rewardsPerStakedToken = (time - farm.lastUpdatedAt)\n        * farm.rewardsDistributionRate\n        * SAFE_MULTIPLIER\n        / farm.totalStaked\n        + farm.rewardsPerStakedToken;\n    }\n\n    if (farm.lastUpdatedAt != farm.endTime) {\n      farm.lastUpdatedAt = block.timestamp < farm.endTime ? block.timestamp\n                                                          : farm.endTime;\n    }\n\n    farms[_id] = farm;\n  }\n\n  /**\n  * Private function used for updating the user rewardsDebt variable\n  * Called when user's stake changes\n  * @param _id  Unique id of farm\n  * @param _user  Address of a user\n  * @param _amount  Amount of new tokens staked or amount of tokens left in farm\n  */\n  function _updateUserRewardsDebt(uint256 _id, address _user, uint256 _amount) private {\n    Position storage position = positions[_id][_user];\n\n    position.rewardsDebt = position.rewardsDebt\n                          + (_amount * farms[_id].rewardsPerStakedToken\n                          * getRewardMultiplier(_id, _user)\n                          / SAFE_MULTIPLIER);\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n  * External function called when a user wants to stake tokens\n  * Called when user is depositing tokens to stake\n  * @param _id  Unique id of farm\n  * @param _amount  Amount of tokens to stake\n  */\n  function stake(uint256 _id, uint256 _amount) external nonReentrant whenNotPaused {\n    require(_id < totalFarms, \"Cannot stake from an unexisting farm\");\n    require(farms[_id].active, \"Farm is not active\");\n    require(_amount > 0, \"Cannot stake 0\");\n\n    claim(_id);\n    _updateFarm(_id);\n    _updateUserRewardsDebt(_id, msg.sender, _amount);\n\n    Position storage position = positions[_id][msg.sender];\n    Farm storage farm = farms[_id];\n\n    position.stakedAmount = position.stakedAmount + _amount;\n\n    farm.totalStaked = farm.totalStaked + _amount;\n\n    IERC20(farm.stakedToken).safeTransferFrom(msg.sender, address(this), _amount);\n\n    emit Stake(_id, msg.sender, farm.stakedToken, _amount);\n  }\n\n  /**\n  * External function called when a user wants to unstake tokens\n  * Called when user is withdrawing staked tokens\n  * @param _id  Unique id of farm\n  * @param _amount  Amount of tokens to withdraw/unstake\n  */\n  function unstake(uint256 _id, uint256 _amount) public nonReentrant whenNotPaused {\n    require(_id < totalFarms, \"Cannot unstake from an unexisting farm\");\n    require(_amount > 0, \"Cannot unstake 0\");\n\n    Position storage position = positions[_id][msg.sender];\n\n    require(position.stakedAmount >= _amount, \"Cannot unstake more than staked\");\n\n    claim(_id);\n    _updateFarm(_id);\n\n    position.rewardsDebt = 0;\n    position.stakedAmount = position.stakedAmount - _amount;\n\n    _updateUserRewardsDebt(_id, msg.sender, position.stakedAmount);\n\n    Farm storage farm = farms[_id];\n    farm.totalStaked = farm.totalStaked - _amount;\n\n    IERC20(farm.stakedToken).safeTransfer(msg.sender, _amount);\n\n    emit Unstake(_id, msg.sender, farm.stakedToken, _amount);\n  }\n\n  /**\n  * External function called when a user wants to redeem reward tokens earned\n  * @param _id  Unique id of farm\n  */\n  function claim(uint256 _id) public whenNotPaused {\n    require(_id < totalFarms, \"Cannot claim from an unexisting farm\");\n\n    uint256 rewards = rewardsEarned(_id, msg.sender);\n\n    if (rewards > 0) {\n      Farm storage farm = farms[_id];\n\n      require(\n        farm.totalRewards >= rewards,\n        \"Rewards deposited in farm less than rewards claimable\"\n      );\n\n      Position memory position = positions[_id][msg.sender];\n\n      position.rewardsRedeemed = position.rewardsRedeemed + rewards;\n      position.rewardsDebt = position.stakedAmount * currentRewardPerStakedToken(_id)\n                            * getRewardMultiplier(_id, msg.sender)\n                            / SAFE_MULTIPLIER;\n      positions[_id][msg.sender] = position;\n\n      farm.totalRewards -= rewards;\n\n      if (farm.esSteadySplit > 0) {\n        uint256 esSteadyAmount = rewards * farm.esSteadySplit / SAFE_MULTIPLIER;\n        uint256 steadyAmount = rewards - esSteadyAmount;\n\n        IERC20(steady).safeTransfer(msg.sender, steadyAmount);\n        ITokenManager(tokenManager).convertTo(esSteadyAmount, msg.sender);\n        } else {\n        IERC20(steady).safeTransfer(msg.sender, rewards);\n      }\n\n      emit Claim(_id, msg.sender, steady, rewards);\n    }\n  }\n\n  /**\n  * External function called when a user wants to redeem all accrued reward tokens\n  * @param _ids  Array of farm ids to claim from\n  */\n  function claimAll(uint256[] calldata _ids) public nonReentrant whenNotPaused {\n    for (uint256 i = 0; i < _ids.length;) {\n      claim(_ids[i]);\n      unchecked { i++; }\n    }\n  }\n\n  /**\n  * Boost a farm position with esSteady to increase multiplier for rewards\n  * Callable only by the YieldBooster contract\n  * @param _id  Unique id of farm\n  * @param _user  Address of user farm position\n  * @param _amount  Amount of esSteady points to boost this position\n  */\n  function boost(\n    uint256 _id,\n    address _user,\n    uint256 _amount\n  ) external nonReentrant whenNotPaused onlyYieldBooster {\n    require(_id < totalFarms, \"Cannot boost an unexisting farm\");\n    require(farms[_id].active, \"Farm is not active\");\n    require(_user != address(0), \"Invalid zero address\");\n    require(_amount > 0, \"Cannot boost 0\");\n\n    claim(_id);\n    _updateFarm(_id);\n    _updateUserRewardsDebt(_id, _user, _amount);\n\n    Position storage position = positions[_id][_user];\n    Farm storage farm = farms[_id];\n\n    position.pointsAmount = position.pointsAmount + _amount;\n    farm.totalPoints = farm.totalPoints + _amount;\n\n    emit Boost(_id, _user, _amount);\n  }\n\n\n  /**\n  * Unboost a farm position of esSteady, reducing multiplier for rewards\n  * Callable only by the YieldBooster contract\n  * @param _id  Unique id of farm\n  * @param _user  Address of user farm position\n  * @param _amount  Amount of esSteady points to unboost this position\n  */\n  function unboost(\n    uint256 _id,\n    address _user,\n    uint256 _amount\n  ) external nonReentrant whenNotPaused onlyYieldBooster {\n    require(_id < totalFarms, \"Cannot unboost an unexisting farm\");\n    require(farms[_id].active, \"Farm is not active\");\n    require(_user != address(0), \"Invalid zero address\");\n    require(_amount > 0, \"Cannot boost 0\");\n\n    claim(_id);\n    _updateFarm(_id);\n    _updateUserRewardsDebt(_id, _user, _amount);\n\n    Position storage position = positions[_id][_user];\n    Farm storage farm = farms[_id];\n\n    position.pointsAmount = position.pointsAmount - _amount;\n    farm.totalPoints = farm.totalPoints - _amount;\n\n    emit Unboost(_id, _user, _amount);\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /**\n  * Create a new Farm\n  * @param _active  Boolean for whether farm is active or not\n  * @param _stakedToken Contract address for the staked tokens\n  * @param _rewardsDistributionRate  Amount of rewards to be distributed per second\n  * @param _esSteadySplit  % split of total rewards to be given in esSteady\n  * @param _maxMultiplier  Max multiplier in 1e18\n  * @param _endTime  Timestamp for when farm will end\n  */\n  function createFarm(\n    bool _active,\n    address _stakedToken,\n    uint256 _rewardsDistributionRate,\n    uint256 _esSteadySplit,\n    uint256 _maxMultiplier,\n    uint256 _endTime\n  ) external onlyOwner {\n    require(_stakedToken != address(0), \"Staked token cannot be zero address\");\n    require(_endTime > block.timestamp, \"End time must be greater than current time\");\n    require(_maxMultiplier >= SAFE_MULTIPLIER, \"Max multiplier must be greater than 1x\");\n\n    Farm memory farm = Farm({\n      id: totalFarms,\n      active: _active,\n      stakedToken: _stakedToken,\n      rewardsDistributionRate: _rewardsDistributionRate,\n      esSteadySplit: _esSteadySplit,\n      rewardsPerStakedToken: 0,\n      lastUpdatedAt: block.timestamp,\n      totalStaked: 0,\n      totalPoints: 0,\n      totalRewards: 0,\n      maxMultiplier: _maxMultiplier,\n      endTime: _endTime\n    });\n\n    farms[totalFarms] = farm;\n    totalFarms += 1;\n  }\n\n  /**\n  * Deposit more reward tokens to a farm\n  * @param _id  Unique id of farm\n  * @param _amount  Amount of reward tokens to deposit; in reward token's decimals\n  */\n  function depositRewardsTokens(uint256 _id, uint256 _amount) external nonReentrant onlyOwner {\n    require(_amount > 0, \"Cannot deposit 0 amount\");\n    require(_id < totalFarms, \"Cannot deposit to unexisting farm\");\n\n    Farm storage farm = farms[_id];\n\n    IERC20(steady).safeTransferFrom(msg.sender, address(this), _amount);\n    farm.totalRewards += _amount;\n\n    emit DepositRewardTokens(_id, _amount);\n  }\n\n  /**\n  * Deposit more reward tokens to a farm\n  * @param _id  Unique id of farm\n  * @param _amount  Amount of reward tokens to deposit; in reward token's decimals\n  */\n  function withdrawRewardsTokens(uint256 _id, uint256 _amount) external nonReentrant onlyOwner {\n    Farm storage farm = farms[_id];\n    require(_amount > 0, \"Cannot withdraw 0 amount\");\n    require(_id < totalFarms, \"Cannot withdraw from unexisting farm\");\n    require(\n      farm.totalRewards > 0, \"Cannot withdraw when farm has no reward tokens deposited\"\n    );\n    require(\n      _amount <= farm.totalRewards,\n      \"Cannot withdraw more reward tokens than deposited in farm\"\n    );\n\n    farm.totalRewards -= _amount;\n    IERC20(steady).safeTransfer(msg.sender, _amount);\n\n    emit WithdrawRewardTokens(_id, _amount);\n  }\n\n  /**\n  * Update a farm's active status\n  * @param _id  Unique id of farm\n  * @param _active  Boolean to set farm to be active or not\n  */\n  function updateActive(uint256 _id, bool _active) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n\n    farms[_id].active = _active;\n\n    emit UpdateActive(_id, _active);\n  }\n\n  /**\n  * Update the reward token distribution rate\n  * @param _id  Unique id of farm\n  * @param _rate  Rate of reward token distribution per second\n  */\n  function updateRewardsDistributionRate(uint256 _id, uint256 _rate) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n    require(_rate >= 0, \"Rate must be >= 0\");\n\n    farms[_id].rewardsDistributionRate = _rate;\n    _updateFarm(_id);\n\n    emit UpdateRewardsDistributionRate(_id, _rate);\n  }\n\n  /**\n  * Update the rewards split % of total rewards to esSteady\n  * @param _id  Unique id of farm\n  * @param _esSteadySplit  Rewards split % of total rewards to esSteady\n  */\n  function updateEsSteadySplit(uint256 _id, uint256 _esSteadySplit) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n    require(_esSteadySplit <= MAX_REWARDS_SPLIT, \"Reward split must be less maximum\");\n\n    farms[_id].esSteadySplit = _esSteadySplit;\n    _updateFarm(_id);\n\n    emit UpdateEsSteadySplit(_id, _esSteadySplit);\n  }\n\n  /**\n  * Update the max multiplier of a farm\n  * @param _id  Unique id of farm\n  * @param _maxMultiplier  Rewards split % of total rewards to esSteady\n  */\n  function updateMaxMultiplier(uint256 _id, uint256 _maxMultiplier) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n    require(_maxMultiplier >= SAFE_MULTIPLIER, \"Max multiplier must be greater than 1x\");\n\n    farms[_id].maxMultiplier = _maxMultiplier;\n    _updateFarm(_id);\n\n    emit UpdateMaxMultiplier(_id, _maxMultiplier);\n  }\n\n  /**\n  * Update the end time of a farm\n  * @param _id  Unique id of farm\n  * @param _endTime  Timestamp of end time for farm\n  */\n  function updateEndTime(uint256 _id, uint256 _endTime) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n    require(_endTime > block.timestamp, \"End time must be greater than current time\");\n\n    farms[_id].endTime = _endTime;\n    _updateFarm(_id);\n\n    emit UpdateEndTime(_id, _endTime);\n  }\n\n  /**\n  * Update yield booster plugin contract address\n  * @param _yieldBooster  Address of yield booster contract\n  */\n  function updateYieldBooster(address _yieldBooster) external onlyOwner {\n    yieldBooster = _yieldBooster;\n\n    emit UpdateYieldBooster(msg.sender, block.timestamp);\n  }\n\n  /**\n  * Update STEADY token manager contract address\n  * @param _tokenManager  Address of token manager contract\n  */\n  function updateTokenManager(address _tokenManager) external onlyOwner {\n    require(_tokenManager != address(0), \"invalid zero address\");\n\n    tokenManager = _tokenManager;\n\n    emit UpdateTokenManager(_tokenManager);\n  }\n\n  /**\n  * Pause farms contract\n  */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n  * Pause farms contract\n  */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n}\n", "test_contract_code": "// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.17;\n\nimport {PTest, console} from \"@narya-ai/contracts/PTest.sol\";\nimport {STEADYbase} from \"../../../contracts/tokens/STEADYbase.sol\";\nimport {esSTEADY} from \"../../../contracts/tokens/esSTEADY.sol\";\nimport {TokenManager} from \"../../../contracts/tokens/TokenManager.sol\";\nimport {Farms} from \"../../../contracts/staking/Farms.sol\";\nimport {ISTEADY} from \"../../../contracts/interfaces/tokens/ISTEADY.sol\";\nimport {IesSTEADY} from \"../../../contracts/interfaces/tokens/IesSTEADY.sol\";\n\ncontract Farms_Test is PTest {\n    STEADYbase steady;\n    esSTEADY esSteady;\n    TokenManager tokenManager;\n    Farms farms;\n\n    address owner;\n    address user1;\n    address user2;\n    address lzEndPoint = 0x3c2269811836af69497E5F486A85D7316753cf62;\n\n    function setUp() public {\n        owner = makeAddr(\"Owner\");\n        user1 = makeAddr(\"User1\");\n        user2 = makeAddr(\"User2\");\n\n        vm.startPrank(owner);\n        steady = new STEADYbase(lzEndPoint);\n        esSteady = new esSTEADY();\n\n        tokenManager = new TokenManager(\n            ISTEADY(address(steady)),\n            IesSTEADY(address(esSteady))\n        );\n\n        esSteady.updateTokenManager(address(tokenManager));\n        esSteady.updateTransferWhitelist(address(tokenManager), true);\n\n        farms = new Farms(\n            address(steady),\n            address(tokenManager)\n        );\n\n        esSteady.updateTransferWhitelist(address(farms), true);\n        steady.approve(address(esSteady), type(uint256).max);\n        steady.approve(address(farms), type(uint256).max);\n        steady.transfer(user1, 1000e18);\n        steady.transfer(user2, 1000e18);\n        vm.stopPrank();\n\n        vm.startPrank(user1);\n        steady.approve(address(esSteady), type(uint256).max);\n        steady.approve(address(farms), type(uint256).max);\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        steady.approve(address(esSteady), type(uint256).max);\n        steady.approve(address(farms), type(uint256).max);\n        vm.stopPrank();\n    }\n\n    function testOwnerCreateANewFarm() public {\n        vm.startPrank(owner);\n        farms.createFarm(\n            true,\n            address(steady),\n            1e17, // rewardDistributionRate\n            8e17, // 0.8 = 80% esRewardSplit\n            25e17, // 2.5 = 2.5 x 1e18 maxMultiplier\n            block.timestamp + 1000000\n        );\n        require(farms.totalFarms() == 1, \"total number of farms is wrong\");\n    }\n\n    function testOwnerDepositRewardTokensToFarm() public {\n        _createNewFarm();\n        vm.startPrank(owner);\n        farms.depositRewardsTokens(0, 100000e18);\n\n        Farms.Farm memory farm0 = _getFarm(0);\n\n        require(farm0.totalRewards == 100000e18, \"Total number of rewards is wrong\");\n    }\n\n    function testUserStakesTokensToFarm() public {\n       _createNewFarm();\n       _ownerDepositsReward();\n\n\n        vm.startPrank(user1);\n        farms.stake(\n            0,\n            10e18\n        );\n        vm.stopPrank();\n\n        Farms.Farm memory farm0 = _getFarm(0);\n        Farms.Position memory positionUser1 = _getPosition(0, user1);\n\n        require(positionUser1.stakedAmount == 10e18, \"Staked amount for user1 is wrong\");\n        require(farm0.totalStaked == 10e18, \"Total staked is wrong\");\n\n    }\n\n    // INTERNAL FUNCTIONS\n    function _createNewFarm() internal {\n        vm.startPrank(owner);\n        farms.createFarm(\n            true,\n            address(steady),\n            1e17, // rewardDistributionRate\n            8e17, // 0.8 = 80% esRewardSplit\n            25e17, // 2.5 = 2.5 x 1e18 maxMultiplier\n            block.timestamp + 1000000\n        );\n        vm.stopPrank();\n    }\n\n    function _userStakesTokensToFarm() internal {\n        vm.startPrank(user1);\n        farms.stake(\n            0,\n            10e18\n        );\n        vm.stopPrank();\n    }\n\n    function _ownerDepositsReward() internal {\n        vm.startPrank(owner);\n        farms.depositRewardsTokens(0, 100000e18);\n        vm.stopPrank();\n    }\n\n    function _getFarm(uint256 _farmId) internal view returns(Farms.Farm memory){\n        Farms.Farm memory farm0;\n        ( , farm0.active, farm0.stakedToken, farm0.rewardsDistributionRate, farm0.rewardsPerStakedToken, , farm0.totalStaked, farm0.totalPoints, farm0.totalRewards, , , farm0.endTime ) = farms.farms(0);\n        return farm0;\n    }\n\n    function _getPosition(\n        uint256 _farmId,\n        address _user\n    ) internal view returns(Farms.Position memory){\n        Farms.Position memory positionUser1;\n        (positionUser1.stakedAmount, positionUser1.rewardsDebt, positionUser1.rewardsRedeemed, positionUser1.pointsAmount ) = farms.positions(_farmId, _user);\n        return positionUser1;\n    }\n}", "function": "Farms.unstake"}, "complete_example": {"contract_code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/plugins/IYieldBooster.sol\";\nimport \"../interfaces/tokens/ITokenManager.sol\";\n\n\ncontract Farms is ReentrancyGuard, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  /* ========== STATE VARIABLES ========== */\n\n  // Counter for total number of farms created\n  uint256 public totalFarms;\n  // Contract address for the Steady token\n  address public immutable steady;\n  // Contract address for the Token Manager\n  address public tokenManager;\n  // Address for Yield Booster plugin for multiplier\n  address public yieldBooster;\n\n  /* ========== CONSTANTS ========== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant MAX_REWARDS_SPLIT = 100 * 1e18; // 100%\n  uint256 public constant MIN_MULTIPLIER = 1 * 1e18; // 1x\n\n  /* ========== STRUCTS ========== */\n\n  struct Farm {\n    // Unique id number of farm\n    uint256 id;\n    // Boolean for whether farm is active or not\n    bool active;\n    // Contract address for the staked token\n    address stakedToken;\n    // Amount of rewards to be distributed per second\n    uint256 rewardsDistributionRate;\n    // Internal calculation of rewards accrued per staked token\n    uint256 rewardsPerStakedToken;\n    // Block timestamp which this farm was last updated at\n    uint256 lastUpdatedAt;\n    // Total amount of tokens staked in this farm\n    uint256 totalStaked;\n    // Total amount of boosted points in this farm\n    uint256 totalPoints;\n    // Total amount of reward tokens deposited in this farm\n    uint256 totalRewards;\n    // % split of total rewards to be given in steady; 100% = 1e18\n    uint256 esSteadySplit;\n    // Maximum multiplier in 1e18\n    uint256 maxMultiplier;\n    // Block timestamp when farm is scheduled to end\n    uint256 endTime;\n  }\n\n  struct Position {\n    // Amount of tokens staked by user in a farm position\n    uint256 stakedAmount;\n    // Calculation for tracking rewards owed to user based on stake changes\n    uint256 rewardsDebt;\n    // Total rewards redeemed by user\n    uint256 rewardsRedeemed;\n    // Amount of boosted points by user in a farm position\n    uint256 pointsAmount;\n  }\n\n  /* ========== MAPPINGS ========== */\n\n  // Mapping of farm id to Farm struct\n  mapping(uint256 => Farm) public farms;\n  // Mapping of farm id to user position address to Position struct\n  mapping(uint256 => mapping(address => Position)) public positions;\n\n  /* ========== EVENTS ========== */\n\n  event Stake(uint256 indexed farmId, address indexed user, address token, uint256 amount);\n  event Unstake(uint256 indexed farmId, address indexed user, address token, uint256 amount);\n  event Claim(uint256 indexed farmId, address indexed user, address token, uint256 amount);\n  event Boost(uint256 indexed farmId, address indexed user, uint256 amount);\n  event Unboost(uint256 indexed farmId, address indexed user, uint256 amount);\n  event UpdateActive(uint256 indexed farmId, bool active);\n  event UpdateRewardsDistributionRate(uint256 indexed farmId, uint256 rate);\n  event UpdateEsSteadySplit(uint256 indexed farmId, uint256 esSteadySplit);\n  event UpdateMaxMultiplier(uint256 indexed farmId, uint256 maxMultiplier);\n  event UpdateEndTime(uint256 indexed farmId, uint256 endTime);\n  event UpdateYieldBooster(address indexed caller, uint256 timestamp);\n  event UpdateTokenManager(address indexed tokenManager);\n  event DepositRewardTokens(uint256 indexed farmId, uint256 amount);\n  event WithdrawRewardTokens(uint256 indexed farmId, uint256 amount);\n\n  /* ========== MODIFIERS ========== */\n\n  /**\n    * Only allow approved addresses for keepers\n  */\n  modifier onlyYieldBooster() {\n    require(msg.sender == yieldBooster, \"Only YieldBooster caller allowed\");\n    _;\n  }\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(address _steady, address _tokenManager) {\n    require(_steady != address(0), \"invalid 0 address\");\n    require(_tokenManager != address(0), \"invalid 0 address\");\n\n    steady = _steady;\n    tokenManager = _tokenManager;\n\n    IERC20(steady).approve(address(tokenManager), type(uint256).max);\n  }\n\n  /* ========== VIEW FUNCTIONS ========== */\n\n  /**\n  * Calculate the current reward accrued per token staked\n  * @param _id  Unique id of farm\n  * @return currentRewardPerStakedToken Current reward per staked token\n  */\n  function currentRewardPerStakedToken(uint256 _id) private view returns (uint256) {\n    Farm storage farm = farms[_id];\n\n    if (farm.totalStaked == 0) {\n      return farm.rewardsDistributionRate;\n    }\n\n    uint256 time = block.timestamp > farm.endTime ? farm.endTime : block.timestamp;\n\n    return (time - farm.lastUpdatedAt)\n            * farm.rewardsDistributionRate\n            * SAFE_MULTIPLIER\n            / farm.totalStaked\n            + farm.rewardsPerStakedToken;\n  }\n\n  /**\n  * Returns the reward tokens currently accrued but not yet redeemed to a user\n  * @param _id  Unique id of farm\n  * @param _user  Address of a user\n  * @return rewardsEarned Total rewards accrued to user\n  */\n  function rewardsEarned(uint256 _id, address _user) public view returns (uint256) {\n    Position memory position = positions[_id][_user];\n\n    if (position.stakedAmount <= 0 || currentRewardPerStakedToken(_id) <= 0) return 0;\n\n    return ((position.stakedAmount * currentRewardPerStakedToken(_id)\n            * getRewardMultiplier(_id, _user)\n            / SAFE_MULTIPLIER)\n            - position.rewardsDebt)\n            / SAFE_MULTIPLIER;\n  }\n\n  /**\n  * Returns the reward multiplier of a user's farm position\n  * @param _id  Unique id of farm\n  * @param _user  Address of a user\n  * @return multiplier  Multiplier in 1e18\n  */\n  function getRewardMultiplier(uint256 _id, address _user) public view returns (uint256) {\n    if (yieldBooster != address(0)) {\n      Farm memory farm = farms[_id];\n      Position memory position = positions[_id][_user];\n\n      return IYieldBooster(yieldBooster).getMultiplier(\n        position.stakedAmount,\n        farm.totalStaked,\n        position.pointsAmount,\n        farm.totalPoints,\n        farm.maxMultiplier\n      );\n    } else {\n      return MIN_MULTIPLIER;\n    }\n  }\n\n  /* ========== INTERNAL FUNCTIONS ========== */\n\n  /**\n  Update farm's reward per staked token value\n  * @param _id  Unique id of farm\n  */\n  function _updateFarm(uint256 _id) internal {\n    Farm memory farm = farms[_id];\n\n    if (farm.totalStaked > 0 && farm.lastUpdatedAt < farm.endTime) {\n      uint256 time = block.timestamp > farm.endTime ? farm.endTime : block.timestamp;\n\n      farm.rewardsPerStakedToken = (time - farm.lastUpdatedAt)\n        * farm.rewardsDistributionRate\n        * SAFE_MULTIPLIER\n        / farm.totalStaked\n        + farm.rewardsPerStakedToken;\n    }\n\n    if (farm.lastUpdatedAt != farm.endTime) {\n      farm.lastUpdatedAt = block.timestamp < farm.endTime ? block.timestamp\n                                                          : farm.endTime;\n    }\n\n    farms[_id] = farm;\n  }\n\n  /**\n  * Private function used for updating the user rewardsDebt variable\n  * Called when user's stake changes\n  * @param _id  Unique id of farm\n  * @param _user  Address of a user\n  * @param _amount  Amount of new tokens staked or amount of tokens left in farm\n  */\n  function _updateUserRewardsDebt(uint256 _id, address _user, uint256 _amount) private {\n    Position storage position = positions[_id][_user];\n\n    position.rewardsDebt = position.rewardsDebt\n                          + (_amount * farms[_id].rewardsPerStakedToken\n                          * getRewardMultiplier(_id, _user)\n                          / SAFE_MULTIPLIER);\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n  * External function called when a user wants to stake tokens\n  * Called when user is depositing tokens to stake\n  * @param _id  Unique id of farm\n  * @param _amount  Amount of tokens to stake\n  */\n  function stake(uint256 _id, uint256 _amount) external nonReentrant whenNotPaused {\n    require(_id < totalFarms, \"Cannot stake from an unexisting farm\");\n    require(farms[_id].active, \"Farm is not active\");\n    require(_amount > 0, \"Cannot stake 0\");\n\n    claim(_id);\n    _updateFarm(_id);\n    _updateUserRewardsDebt(_id, msg.sender, _amount);\n\n    Position storage position = positions[_id][msg.sender];\n    Farm storage farm = farms[_id];\n\n    position.stakedAmount = position.stakedAmount + _amount;\n\n    farm.totalStaked = farm.totalStaked + _amount;\n\n    IERC20(farm.stakedToken).safeTransferFrom(msg.sender, address(this), _amount);\n\n    emit Stake(_id, msg.sender, farm.stakedToken, _amount);\n  }\n\n  /**\n  * External function called when a user wants to unstake tokens\n  * Called when user is withdrawing staked tokens\n  * @param _id  Unique id of farm\n  * @param _amount  Amount of tokens to withdraw/unstake\n  */\n  function unstake(uint256 _id, uint256 _amount) public nonReentrant whenNotPaused {\n    require(_id < totalFarms, \"Cannot unstake from an unexisting farm\");\n    require(_amount > 0, \"Cannot unstake 0\");\n\n    Position storage position = positions[_id][msg.sender];\n\n    require(position.stakedAmount >= _amount, \"Cannot unstake more than staked\");\n\n    claim(_id);\n    _updateFarm(_id);\n\n    position.rewardsDebt = 0;\n    position.stakedAmount = position.stakedAmount - _amount;\n\n    _updateUserRewardsDebt(_id, msg.sender, position.stakedAmount);\n\n    Farm storage farm = farms[_id];\n    farm.totalStaked = farm.totalStaked - _amount;\n\n    IERC20(farm.stakedToken).safeTransfer(msg.sender, _amount);\n\n    emit Unstake(_id, msg.sender, farm.stakedToken, _amount);\n  }\n\n  /**\n  * External function called when a user wants to redeem reward tokens earned\n  * @param _id  Unique id of farm\n  */\n  function claim(uint256 _id) public whenNotPaused {\n    require(_id < totalFarms, \"Cannot claim from an unexisting farm\");\n\n    uint256 rewards = rewardsEarned(_id, msg.sender);\n\n    if (rewards > 0) {\n      Farm storage farm = farms[_id];\n\n      require(\n        farm.totalRewards >= rewards,\n        \"Rewards deposited in farm less than rewards claimable\"\n      );\n\n      Position memory position = positions[_id][msg.sender];\n\n      position.rewardsRedeemed = position.rewardsRedeemed + rewards;\n      position.rewardsDebt = position.stakedAmount * currentRewardPerStakedToken(_id)\n                            * getRewardMultiplier(_id, msg.sender)\n                            / SAFE_MULTIPLIER;\n      positions[_id][msg.sender] = position;\n\n      farm.totalRewards -= rewards;\n\n      if (farm.esSteadySplit > 0) {\n        uint256 esSteadyAmount = rewards * farm.esSteadySplit / SAFE_MULTIPLIER;\n        uint256 steadyAmount = rewards - esSteadyAmount;\n\n        IERC20(steady).safeTransfer(msg.sender, steadyAmount);\n        ITokenManager(tokenManager).convertTo(esSteadyAmount, msg.sender);\n        } else {\n        IERC20(steady).safeTransfer(msg.sender, rewards);\n      }\n\n      emit Claim(_id, msg.sender, steady, rewards);\n    }\n  }\n\n  /**\n  * External function called when a user wants to redeem all accrued reward tokens\n  * @param _ids  Array of farm ids to claim from\n  */\n  function claimAll(uint256[] calldata _ids) public nonReentrant whenNotPaused {\n    for (uint256 i = 0; i < _ids.length;) {\n      claim(_ids[i]);\n      unchecked { i++; }\n    }\n  }\n\n  /**\n  * Boost a farm position with esSteady to increase multiplier for rewards\n  * Callable only by the YieldBooster contract\n  * @param _id  Unique id of farm\n  * @param _user  Address of user farm position\n  * @param _amount  Amount of esSteady points to boost this position\n  */\n  function boost(\n    uint256 _id,\n    address _user,\n    uint256 _amount\n  ) external nonReentrant whenNotPaused onlyYieldBooster {\n    require(_id < totalFarms, \"Cannot boost an unexisting farm\");\n    require(farms[_id].active, \"Farm is not active\");\n    require(_user != address(0), \"Invalid zero address\");\n    require(_amount > 0, \"Cannot boost 0\");\n\n    claim(_id);\n    _updateFarm(_id);\n    _updateUserRewardsDebt(_id, _user, _amount);\n\n    Position storage position = positions[_id][_user];\n    Farm storage farm = farms[_id];\n\n    position.pointsAmount = position.pointsAmount + _amount;\n    farm.totalPoints = farm.totalPoints + _amount;\n\n    emit Boost(_id, _user, _amount);\n  }\n\n\n  /**\n  * Unboost a farm position of esSteady, reducing multiplier for rewards\n  * Callable only by the YieldBooster contract\n  * @param _id  Unique id of farm\n  * @param _user  Address of user farm position\n  * @param _amount  Amount of esSteady points to unboost this position\n  */\n  function unboost(\n    uint256 _id,\n    address _user,\n    uint256 _amount\n  ) external nonReentrant whenNotPaused onlyYieldBooster {\n    require(_id < totalFarms, \"Cannot unboost an unexisting farm\");\n    require(farms[_id].active, \"Farm is not active\");\n    require(_user != address(0), \"Invalid zero address\");\n    require(_amount > 0, \"Cannot boost 0\");\n\n    claim(_id);\n    _updateFarm(_id);\n    _updateUserRewardsDebt(_id, _user, _amount);\n\n    Position storage position = positions[_id][_user];\n    Farm storage farm = farms[_id];\n\n    position.pointsAmount = position.pointsAmount - _amount;\n    farm.totalPoints = farm.totalPoints - _amount;\n\n    emit Unboost(_id, _user, _amount);\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /**\n  * Create a new Farm\n  * @param _active  Boolean for whether farm is active or not\n  * @param _stakedToken Contract address for the staked tokens\n  * @param _rewardsDistributionRate  Amount of rewards to be distributed per second\n  * @param _esSteadySplit  % split of total rewards to be given in esSteady\n  * @param _maxMultiplier  Max multiplier in 1e18\n  * @param _endTime  Timestamp for when farm will end\n  */\n  function createFarm(\n    bool _active,\n    address _stakedToken,\n    uint256 _rewardsDistributionRate,\n    uint256 _esSteadySplit,\n    uint256 _maxMultiplier,\n    uint256 _endTime\n  ) external onlyOwner {\n    require(_stakedToken != address(0), \"Staked token cannot be zero address\");\n    require(_endTime > block.timestamp, \"End time must be greater than current time\");\n    require(_maxMultiplier >= SAFE_MULTIPLIER, \"Max multiplier must be greater than 1x\");\n\n    Farm memory farm = Farm({\n      id: totalFarms,\n      active: _active,\n      stakedToken: _stakedToken,\n      rewardsDistributionRate: _rewardsDistributionRate,\n      esSteadySplit: _esSteadySplit,\n      rewardsPerStakedToken: 0,\n      lastUpdatedAt: block.timestamp,\n      totalStaked: 0,\n      totalPoints: 0,\n      totalRewards: 0,\n      maxMultiplier: _maxMultiplier,\n      endTime: _endTime\n    });\n\n    farms[totalFarms] = farm;\n    totalFarms += 1;\n  }\n\n  /**\n  * Deposit more reward tokens to a farm\n  * @param _id  Unique id of farm\n  * @param _amount  Amount of reward tokens to deposit; in reward token's decimals\n  */\n  function depositRewardsTokens(uint256 _id, uint256 _amount) external nonReentrant onlyOwner {\n    require(_amount > 0, \"Cannot deposit 0 amount\");\n    require(_id < totalFarms, \"Cannot deposit to unexisting farm\");\n\n    Farm storage farm = farms[_id];\n\n    IERC20(steady).safeTransferFrom(msg.sender, address(this), _amount);\n    farm.totalRewards += _amount;\n\n    emit DepositRewardTokens(_id, _amount);\n  }\n\n  /**\n  * Deposit more reward tokens to a farm\n  * @param _id  Unique id of farm\n  * @param _amount  Amount of reward tokens to deposit; in reward token's decimals\n  */\n  function withdrawRewardsTokens(uint256 _id, uint256 _amount) external nonReentrant onlyOwner {\n    Farm storage farm = farms[_id];\n    require(_amount > 0, \"Cannot withdraw 0 amount\");\n    require(_id < totalFarms, \"Cannot withdraw from unexisting farm\");\n    require(\n      farm.totalRewards > 0, \"Cannot withdraw when farm has no reward tokens deposited\"\n    );\n    require(\n      _amount <= farm.totalRewards,\n      \"Cannot withdraw more reward tokens than deposited in farm\"\n    );\n\n    farm.totalRewards -= _amount;\n    IERC20(steady).safeTransfer(msg.sender, _amount);\n\n    emit WithdrawRewardTokens(_id, _amount);\n  }\n\n  /**\n  * Update a farm's active status\n  * @param _id  Unique id of farm\n  * @param _active  Boolean to set farm to be active or not\n  */\n  function updateActive(uint256 _id, bool _active) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n\n    farms[_id].active = _active;\n\n    emit UpdateActive(_id, _active);\n  }\n\n  /**\n  * Update the reward token distribution rate\n  * @param _id  Unique id of farm\n  * @param _rate  Rate of reward token distribution per second\n  */\n  function updateRewardsDistributionRate(uint256 _id, uint256 _rate) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n    require(_rate >= 0, \"Rate must be >= 0\");\n\n    farms[_id].rewardsDistributionRate = _rate;\n    _updateFarm(_id);\n\n    emit UpdateRewardsDistributionRate(_id, _rate);\n  }\n\n  /**\n  * Update the rewards split % of total rewards to esSteady\n  * @param _id  Unique id of farm\n  * @param _esSteadySplit  Rewards split % of total rewards to esSteady\n  */\n  function updateEsSteadySplit(uint256 _id, uint256 _esSteadySplit) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n    require(_esSteadySplit <= MAX_REWARDS_SPLIT, \"Reward split must be less maximum\");\n\n    farms[_id].esSteadySplit = _esSteadySplit;\n    _updateFarm(_id);\n\n    emit UpdateEsSteadySplit(_id, _esSteadySplit);\n  }\n\n  /**\n  * Update the max multiplier of a farm\n  * @param _id  Unique id of farm\n  * @param _maxMultiplier  Rewards split % of total rewards to esSteady\n  */\n  function updateMaxMultiplier(uint256 _id, uint256 _maxMultiplier) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n    require(_maxMultiplier >= SAFE_MULTIPLIER, \"Max multiplier must be greater than 1x\");\n\n    farms[_id].maxMultiplier = _maxMultiplier;\n    _updateFarm(_id);\n\n    emit UpdateMaxMultiplier(_id, _maxMultiplier);\n  }\n\n  /**\n  * Update the end time of a farm\n  * @param _id  Unique id of farm\n  * @param _endTime  Timestamp of end time for farm\n  */\n  function updateEndTime(uint256 _id, uint256 _endTime) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n    require(_endTime > block.timestamp, \"End time must be greater than current time\");\n\n    farms[_id].endTime = _endTime;\n    _updateFarm(_id);\n\n    emit UpdateEndTime(_id, _endTime);\n  }\n\n  /**\n  * Update yield booster plugin contract address\n  * @param _yieldBooster  Address of yield booster contract\n  */\n  function updateYieldBooster(address _yieldBooster) external onlyOwner {\n    yieldBooster = _yieldBooster;\n\n    emit UpdateYieldBooster(msg.sender, block.timestamp);\n  }\n\n  /**\n  * Update STEADY token manager contract address\n  * @param _tokenManager  Address of token manager contract\n  */\n  function updateTokenManager(address _tokenManager) external onlyOwner {\n    require(_tokenManager != address(0), \"invalid zero address\");\n\n    tokenManager = _tokenManager;\n\n    emit UpdateTokenManager(_tokenManager);\n  }\n\n  /**\n  * Pause farms contract\n  */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n  * Pause farms contract\n  */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n}\n", "test_contract_code": "// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.17;\n\nimport {PTest, console} from \"@narya-ai/contracts/PTest.sol\";\nimport {STEADYbase} from \"../../../contracts/tokens/STEADYbase.sol\";\nimport {esSTEADY} from \"../../../contracts/tokens/esSTEADY.sol\";\nimport {TokenManager} from \"../../../contracts/tokens/TokenManager.sol\";\nimport {Farms} from \"../../../contracts/staking/Farms.sol\";\nimport {ISTEADY} from \"../../../contracts/interfaces/tokens/ISTEADY.sol\";\nimport {IesSTEADY} from \"../../../contracts/interfaces/tokens/IesSTEADY.sol\";\n\ncontract Farms_Test is PTest {\n    STEADYbase steady;\n    esSTEADY esSteady;\n    TokenManager tokenManager;\n    Farms farms;\n\n    address owner;\n    address user1;\n    address user2;\n    address lzEndPoint = 0x3c2269811836af69497E5F486A85D7316753cf62;\n\n    function setUp() public {\n        owner = makeAddr(\"Owner\");\n        user1 = makeAddr(\"User1\");\n        user2 = makeAddr(\"User2\");\n\n        vm.startPrank(owner);\n        steady = new STEADYbase(lzEndPoint);\n        esSteady = new esSTEADY();\n\n        tokenManager = new TokenManager(\n            ISTEADY(address(steady)),\n            IesSTEADY(address(esSteady))\n        );\n\n        esSteady.updateTokenManager(address(tokenManager));\n        esSteady.updateTransferWhitelist(address(tokenManager), true);\n\n        farms = new Farms(\n            address(steady),\n            address(tokenManager)\n        );\n\n        esSteady.updateTransferWhitelist(address(farms), true);\n        steady.approve(address(esSteady), type(uint256).max);\n        steady.approve(address(farms), type(uint256).max);\n        steady.transfer(user1, 1000e18);\n        steady.transfer(user2, 1000e18);\n        vm.stopPrank();\n\n        vm.startPrank(user1);\n        steady.approve(address(esSteady), type(uint256).max);\n        steady.approve(address(farms), type(uint256).max);\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        steady.approve(address(esSteady), type(uint256).max);\n        steady.approve(address(farms), type(uint256).max);\n        vm.stopPrank();\n    }\n\n    function testOwnerCreateANewFarm() public {\n        vm.startPrank(owner);\n        farms.createFarm(\n            true,\n            address(steady),\n            1e17, // rewardDistributionRate\n            8e17, // 0.8 = 80% esRewardSplit\n            25e17, // 2.5 = 2.5 x 1e18 maxMultiplier\n            block.timestamp + 1000000\n        );\n        require(farms.totalFarms() == 1, \"total number of farms is wrong\");\n    }\n\n    function testOwnerDepositRewardTokensToFarm() public {\n        _createNewFarm();\n        vm.startPrank(owner);\n        farms.depositRewardsTokens(0, 100000e18);\n\n        Farms.Farm memory farm0 = _getFarm(0);\n\n        require(farm0.totalRewards == 100000e18, \"Total number of rewards is wrong\");\n    }\n\n    function testUserStakesTokensToFarm() public {\n       _createNewFarm();\n       _ownerDepositsReward();\n\n\n        vm.startPrank(user1);\n        farms.stake(\n            0,\n            10e18\n        );\n        vm.stopPrank();\n\n        Farms.Farm memory farm0 = _getFarm(0);\n        Farms.Position memory positionUser1 = _getPosition(0, user1);\n\n        require(positionUser1.stakedAmount == 10e18, \"Staked amount for user1 is wrong\");\n        require(farm0.totalStaked == 10e18, \"Total staked is wrong\");\n\n    }\n\n    // INTERNAL FUNCTIONS\n    function _createNewFarm() internal {\n        vm.startPrank(owner);\n        farms.createFarm(\n            true,\n            address(steady),\n            1e17, // rewardDistributionRate\n            8e17, // 0.8 = 80% esRewardSplit\n            25e17, // 2.5 = 2.5 x 1e18 maxMultiplier\n            block.timestamp + 1000000\n        );\n        vm.stopPrank();\n    }\n\n    function _userStakesTokensToFarm() internal {\n        vm.startPrank(user1);\n        farms.stake(\n            0,\n            10e18\n        );\n        vm.stopPrank();\n    }\n\n    function _ownerDepositsReward() internal {\n        vm.startPrank(owner);\n        farms.depositRewardsTokens(0, 100000e18);\n        vm.stopPrank();\n    }\n\n    function _getFarm(uint256 _farmId) internal view returns(Farms.Farm memory){\n        Farms.Farm memory farm0;\n        ( , farm0.active, farm0.stakedToken, farm0.rewardsDistributionRate, farm0.rewardsPerStakedToken, , farm0.totalStaked, farm0.totalPoints, farm0.totalRewards, , , farm0.endTime ) = farms.farms(0);\n        return farm0;\n    }\n\n    function _getPosition(\n        uint256 _farmId,\n        address _user\n    ) internal view returns(Farms.Position memory){\n        Farms.Position memory positionUser1;\n        (positionUser1.stakedAmount, positionUser1.rewardsDebt, positionUser1.rewardsRedeemed, positionUser1.pointsAmount ) = farms.positions(_farmId, _user);\n        return positionUser1;\n    }\n}", "function": "Farms.claim"}, "complete_example_answer": "Here is an example:\n\nSMART CONTRACT CODE:\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/plugins/IYieldBooster.sol\";\nimport \"../interfaces/tokens/ITokenManager.sol\";\n\n\ncontract Farms is ReentrancyGuard, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  /* ========== STATE VARIABLES ========== */\n\n  // Counter for total number of farms created\n  uint256 public totalFarms;\n  // Contract address for the Steady token\n  address public immutable steady;\n  // Contract address for the Token Manager\n  address public tokenManager;\n  // Address for Yield Booster plugin for multiplier\n  address public yieldBooster;\n\n  /* ========== CONSTANTS ========== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant MAX_REWARDS_SPLIT = 100 * 1e18; // 100%\n  uint256 public constant MIN_MULTIPLIER = 1 * 1e18; // 1x\n\n  /* ========== STRUCTS ========== */\n\n  struct Farm {\n    // Unique id number of farm\n    uint256 id;\n    // Boolean for whether farm is active or not\n    bool active;\n    // Contract address for the staked token\n    address stakedToken;\n    // Amount of rewards to be distributed per second\n    uint256 rewardsDistributionRate;\n    // Internal calculation of rewards accrued per staked token\n    uint256 rewardsPerStakedToken;\n    // Block timestamp which this farm was last updated at\n    uint256 lastUpdatedAt;\n    // Total amount of tokens staked in this farm\n    uint256 totalStaked;\n    // Total amount of boosted points in this farm\n    uint256 totalPoints;\n    // Total amount of reward tokens deposited in this farm\n    uint256 totalRewards;\n    // % split of total rewards to be given in steady; 100% = 1e18\n    uint256 esSteadySplit;\n    // Maximum multiplier in 1e18\n    uint256 maxMultiplier;\n    // Block timestamp when farm is scheduled to end\n    uint256 endTime;\n  }\n\n  struct Position {\n    // Amount of tokens staked by user in a farm position\n    uint256 stakedAmount;\n    // Calculation for tracking rewards owed to user based on stake changes\n    uint256 rewardsDebt;\n    // Total rewards redeemed by user\n    uint256 rewardsRedeemed;\n    // Amount of boosted points by user in a farm position\n    uint256 pointsAmount;\n  }\n\n  /* ========== MAPPINGS ========== */\n\n  // Mapping of farm id to Farm struct\n  mapping(uint256 => Farm) public farms;\n  // Mapping of farm id to user position address to Position struct\n  mapping(uint256 => mapping(address => Position)) public positions;\n\n  /* ========== EVENTS ========== */\n\n  event Stake(uint256 indexed farmId, address indexed user, address token, uint256 amount);\n  event Unstake(uint256 indexed farmId, address indexed user, address token, uint256 amount);\n  event Claim(uint256 indexed farmId, address indexed user, address token, uint256 amount);\n  event Boost(uint256 indexed farmId, address indexed user, uint256 amount);\n  event Unboost(uint256 indexed farmId, address indexed user, uint256 amount);\n  event UpdateActive(uint256 indexed farmId, bool active);\n  event UpdateRewardsDistributionRate(uint256 indexed farmId, uint256 rate);\n  event UpdateEsSteadySplit(uint256 indexed farmId, uint256 esSteadySplit);\n  event UpdateMaxMultiplier(uint256 indexed farmId, uint256 maxMultiplier);\n  event UpdateEndTime(uint256 indexed farmId, uint256 endTime);\n  event UpdateYieldBooster(address indexed caller, uint256 timestamp);\n  event UpdateTokenManager(address indexed tokenManager);\n  event DepositRewardTokens(uint256 indexed farmId, uint256 amount);\n  event WithdrawRewardTokens(uint256 indexed farmId, uint256 amount);\n\n  /* ========== MODIFIERS ========== */\n\n  /**\n    * Only allow approved addresses for keepers\n  */\n  modifier onlyYieldBooster() {\n    require(msg.sender == yieldBooster, \"Only YieldBooster caller allowed\");\n    _;\n  }\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(address _steady, address _tokenManager) {\n    require(_steady != address(0), \"invalid 0 address\");\n    require(_tokenManager != address(0), \"invalid 0 address\");\n\n    steady = _steady;\n    tokenManager = _tokenManager;\n\n    IERC20(steady).approve(address(tokenManager), type(uint256).max);\n  }\n\n  /* ========== VIEW FUNCTIONS ========== */\n\n  /**\n  * Calculate the current reward accrued per token staked\n  * @param _id  Unique id of farm\n  * @return currentRewardPerStakedToken Current reward per staked token\n  */\n  function currentRewardPerStakedToken(uint256 _id) private view returns (uint256) {\n    Farm storage farm = farms[_id];\n\n    if (farm.totalStaked == 0) {\n      return farm.rewardsDistributionRate;\n    }\n\n    uint256 time = block.timestamp > farm.endTime ? farm.endTime : block.timestamp;\n\n    return (time - farm.lastUpdatedAt)\n            * farm.rewardsDistributionRate\n            * SAFE_MULTIPLIER\n            / farm.totalStaked\n            + farm.rewardsPerStakedToken;\n  }\n\n  /**\n  * Returns the reward tokens currently accrued but not yet redeemed to a user\n  * @param _id  Unique id of farm\n  * @param _user  Address of a user\n  * @return rewardsEarned Total rewards accrued to user\n  */\n  function rewardsEarned(uint256 _id, address _user) public view returns (uint256) {\n    Position memory position = positions[_id][_user];\n\n    if (position.stakedAmount <= 0 || currentRewardPerStakedToken(_id) <= 0) return 0;\n\n    return ((position.stakedAmount * currentRewardPerStakedToken(_id)\n            * getRewardMultiplier(_id, _user)\n            / SAFE_MULTIPLIER)\n            - position.rewardsDebt)\n            / SAFE_MULTIPLIER;\n  }\n\n  /**\n  * Returns the reward multiplier of a user's farm position\n  * @param _id  Unique id of farm\n  * @param _user  Address of a user\n  * @return multiplier  Multiplier in 1e18\n  */\n  function getRewardMultiplier(uint256 _id, address _user) public view returns (uint256) {\n    if (yieldBooster != address(0)) {\n      Farm memory farm = farms[_id];\n      Position memory position = positions[_id][_user];\n\n      return IYieldBooster(yieldBooster).getMultiplier(\n        position.stakedAmount,\n        farm.totalStaked,\n        position.pointsAmount,\n        farm.totalPoints,\n        farm.maxMultiplier\n      );\n    } else {\n      return MIN_MULTIPLIER;\n    }\n  }\n\n  /* ========== INTERNAL FUNCTIONS ========== */\n\n  /**\n  Update farm's reward per staked token value\n  * @param _id  Unique id of farm\n  */\n  function _updateFarm(uint256 _id) internal {\n    Farm memory farm = farms[_id];\n\n    if (farm.totalStaked > 0 && farm.lastUpdatedAt < farm.endTime) {\n      uint256 time = block.timestamp > farm.endTime ? farm.endTime : block.timestamp;\n\n      farm.rewardsPerStakedToken = (time - farm.lastUpdatedAt)\n        * farm.rewardsDistributionRate\n        * SAFE_MULTIPLIER\n        / farm.totalStaked\n        + farm.rewardsPerStakedToken;\n    }\n\n    if (farm.lastUpdatedAt != farm.endTime) {\n      farm.lastUpdatedAt = block.timestamp < farm.endTime ? block.timestamp\n                                                          : farm.endTime;\n    }\n\n    farms[_id] = farm;\n  }\n\n  /**\n  * Private function used for updating the user rewardsDebt variable\n  * Called when user's stake changes\n  * @param _id  Unique id of farm\n  * @param _user  Address of a user\n  * @param _amount  Amount of new tokens staked or amount of tokens left in farm\n  */\n  function _updateUserRewardsDebt(uint256 _id, address _user, uint256 _amount) private {\n    Position storage position = positions[_id][_user];\n\n    position.rewardsDebt = position.rewardsDebt\n                          + (_amount * farms[_id].rewardsPerStakedToken\n                          * getRewardMultiplier(_id, _user)\n                          / SAFE_MULTIPLIER);\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n  * External function called when a user wants to stake tokens\n  * Called when user is depositing tokens to stake\n  * @param _id  Unique id of farm\n  * @param _amount  Amount of tokens to stake\n  */\n  function stake(uint256 _id, uint256 _amount) external nonReentrant whenNotPaused {\n    require(_id < totalFarms, \"Cannot stake from an unexisting farm\");\n    require(farms[_id].active, \"Farm is not active\");\n    require(_amount > 0, \"Cannot stake 0\");\n\n    claim(_id);\n    _updateFarm(_id);\n    _updateUserRewardsDebt(_id, msg.sender, _amount);\n\n    Position storage position = positions[_id][msg.sender];\n    Farm storage farm = farms[_id];\n\n    position.stakedAmount = position.stakedAmount + _amount;\n\n    farm.totalStaked = farm.totalStaked + _amount;\n\n    IERC20(farm.stakedToken).safeTransferFrom(msg.sender, address(this), _amount);\n\n    emit Stake(_id, msg.sender, farm.stakedToken, _amount);\n  }\n\n  /**\n  * External function called when a user wants to unstake tokens\n  * Called when user is withdrawing staked tokens\n  * @param _id  Unique id of farm\n  * @param _amount  Amount of tokens to withdraw/unstake\n  */\n  function unstake(uint256 _id, uint256 _amount) public nonReentrant whenNotPaused {\n    require(_id < totalFarms, \"Cannot unstake from an unexisting farm\");\n    require(_amount > 0, \"Cannot unstake 0\");\n\n    Position storage position = positions[_id][msg.sender];\n\n    require(position.stakedAmount >= _amount, \"Cannot unstake more than staked\");\n\n    claim(_id);\n    _updateFarm(_id);\n\n    position.rewardsDebt = 0;\n    position.stakedAmount = position.stakedAmount - _amount;\n\n    _updateUserRewardsDebt(_id, msg.sender, position.stakedAmount);\n\n    Farm storage farm = farms[_id];\n    farm.totalStaked = farm.totalStaked - _amount;\n\n    IERC20(farm.stakedToken).safeTransfer(msg.sender, _amount);\n\n    emit Unstake(_id, msg.sender, farm.stakedToken, _amount);\n  }\n\n  /**\n  * External function called when a user wants to redeem reward tokens earned\n  * @param _id  Unique id of farm\n  */\n  function claim(uint256 _id) public whenNotPaused {\n    require(_id < totalFarms, \"Cannot claim from an unexisting farm\");\n\n    uint256 rewards = rewardsEarned(_id, msg.sender);\n\n    if (rewards > 0) {\n      Farm storage farm = farms[_id];\n\n      require(\n        farm.totalRewards >= rewards,\n        \"Rewards deposited in farm less than rewards claimable\"\n      );\n\n      Position memory position = positions[_id][msg.sender];\n\n      position.rewardsRedeemed = position.rewardsRedeemed + rewards;\n      position.rewardsDebt = position.stakedAmount * currentRewardPerStakedToken(_id)\n                            * getRewardMultiplier(_id, msg.sender)\n                            / SAFE_MULTIPLIER;\n      positions[_id][msg.sender] = position;\n\n      farm.totalRewards -= rewards;\n\n      if (farm.esSteadySplit > 0) {\n        uint256 esSteadyAmount = rewards * farm.esSteadySplit / SAFE_MULTIPLIER;\n        uint256 steadyAmount = rewards - esSteadyAmount;\n\n        IERC20(steady).safeTransfer(msg.sender, steadyAmount);\n        ITokenManager(tokenManager).convertTo(esSteadyAmount, msg.sender);\n        } else {\n        IERC20(steady).safeTransfer(msg.sender, rewards);\n      }\n\n      emit Claim(_id, msg.sender, steady, rewards);\n    }\n  }\n\n  /**\n  * External function called when a user wants to redeem all accrued reward tokens\n  * @param _ids  Array of farm ids to claim from\n  */\n  function claimAll(uint256[] calldata _ids) public nonReentrant whenNotPaused {\n    for (uint256 i = 0; i < _ids.length;) {\n      claim(_ids[i]);\n      unchecked { i++; }\n    }\n  }\n\n  /**\n  * Boost a farm position with esSteady to increase multiplier for rewards\n  * Callable only by the YieldBooster contract\n  * @param _id  Unique id of farm\n  * @param _user  Address of user farm position\n  * @param _amount  Amount of esSteady points to boost this position\n  */\n  function boost(\n    uint256 _id,\n    address _user,\n    uint256 _amount\n  ) external nonReentrant whenNotPaused onlyYieldBooster {\n    require(_id < totalFarms, \"Cannot boost an unexisting farm\");\n    require(farms[_id].active, \"Farm is not active\");\n    require(_user != address(0), \"Invalid zero address\");\n    require(_amount > 0, \"Cannot boost 0\");\n\n    claim(_id);\n    _updateFarm(_id);\n    _updateUserRewardsDebt(_id, _user, _amount);\n\n    Position storage position = positions[_id][_user];\n    Farm storage farm = farms[_id];\n\n    position.pointsAmount = position.pointsAmount + _amount;\n    farm.totalPoints = farm.totalPoints + _amount;\n\n    emit Boost(_id, _user, _amount);\n  }\n\n\n  /**\n  * Unboost a farm position of esSteady, reducing multiplier for rewards\n  * Callable only by the YieldBooster contract\n  * @param _id  Unique id of farm\n  * @param _user  Address of user farm position\n  * @param _amount  Amount of esSteady points to unboost this position\n  */\n  function unboost(\n    uint256 _id,\n    address _user,\n    uint256 _amount\n  ) external nonReentrant whenNotPaused onlyYieldBooster {\n    require(_id < totalFarms, \"Cannot unboost an unexisting farm\");\n    require(farms[_id].active, \"Farm is not active\");\n    require(_user != address(0), \"Invalid zero address\");\n    require(_amount > 0, \"Cannot boost 0\");\n\n    claim(_id);\n    _updateFarm(_id);\n    _updateUserRewardsDebt(_id, _user, _amount);\n\n    Position storage position = positions[_id][_user];\n    Farm storage farm = farms[_id];\n\n    position.pointsAmount = position.pointsAmount - _amount;\n    farm.totalPoints = farm.totalPoints - _amount;\n\n    emit Unboost(_id, _user, _amount);\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /**\n  * Create a new Farm\n  * @param _active  Boolean for whether farm is active or not\n  * @param _stakedToken Contract address for the staked tokens\n  * @param _rewardsDistributionRate  Amount of rewards to be distributed per second\n  * @param _esSteadySplit  % split of total rewards to be given in esSteady\n  * @param _maxMultiplier  Max multiplier in 1e18\n  * @param _endTime  Timestamp for when farm will end\n  */\n  function createFarm(\n    bool _active,\n    address _stakedToken,\n    uint256 _rewardsDistributionRate,\n    uint256 _esSteadySplit,\n    uint256 _maxMultiplier,\n    uint256 _endTime\n  ) external onlyOwner {\n    require(_stakedToken != address(0), \"Staked token cannot be zero address\");\n    require(_endTime > block.timestamp, \"End time must be greater than current time\");\n    require(_maxMultiplier >= SAFE_MULTIPLIER, \"Max multiplier must be greater than 1x\");\n\n    Farm memory farm = Farm({\n      id: totalFarms,\n      active: _active,\n      stakedToken: _stakedToken,\n      rewardsDistributionRate: _rewardsDistributionRate,\n      esSteadySplit: _esSteadySplit,\n      rewardsPerStakedToken: 0,\n      lastUpdatedAt: block.timestamp,\n      totalStaked: 0,\n      totalPoints: 0,\n      totalRewards: 0,\n      maxMultiplier: _maxMultiplier,\n      endTime: _endTime\n    });\n\n    farms[totalFarms] = farm;\n    totalFarms += 1;\n  }\n\n  /**\n  * Deposit more reward tokens to a farm\n  * @param _id  Unique id of farm\n  * @param _amount  Amount of reward tokens to deposit; in reward token's decimals\n  */\n  function depositRewardsTokens(uint256 _id, uint256 _amount) external nonReentrant onlyOwner {\n    require(_amount > 0, \"Cannot deposit 0 amount\");\n    require(_id < totalFarms, \"Cannot deposit to unexisting farm\");\n\n    Farm storage farm = farms[_id];\n\n    IERC20(steady).safeTransferFrom(msg.sender, address(this), _amount);\n    farm.totalRewards += _amount;\n\n    emit DepositRewardTokens(_id, _amount);\n  }\n\n  /**\n  * Deposit more reward tokens to a farm\n  * @param _id  Unique id of farm\n  * @param _amount  Amount of reward tokens to deposit; in reward token's decimals\n  */\n  function withdrawRewardsTokens(uint256 _id, uint256 _amount) external nonReentrant onlyOwner {\n    Farm storage farm = farms[_id];\n    require(_amount > 0, \"Cannot withdraw 0 amount\");\n    require(_id < totalFarms, \"Cannot withdraw from unexisting farm\");\n    require(\n      farm.totalRewards > 0, \"Cannot withdraw when farm has no reward tokens deposited\"\n    );\n    require(\n      _amount <= farm.totalRewards,\n      \"Cannot withdraw more reward tokens than deposited in farm\"\n    );\n\n    farm.totalRewards -= _amount;\n    IERC20(steady).safeTransfer(msg.sender, _amount);\n\n    emit WithdrawRewardTokens(_id, _amount);\n  }\n\n  /**\n  * Update a farm's active status\n  * @param _id  Unique id of farm\n  * @param _active  Boolean to set farm to be active or not\n  */\n  function updateActive(uint256 _id, bool _active) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n\n    farms[_id].active = _active;\n\n    emit UpdateActive(_id, _active);\n  }\n\n  /**\n  * Update the reward token distribution rate\n  * @param _id  Unique id of farm\n  * @param _rate  Rate of reward token distribution per second\n  */\n  function updateRewardsDistributionRate(uint256 _id, uint256 _rate) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n    require(_rate >= 0, \"Rate must be >= 0\");\n\n    farms[_id].rewardsDistributionRate = _rate;\n    _updateFarm(_id);\n\n    emit UpdateRewardsDistributionRate(_id, _rate);\n  }\n\n  /**\n  * Update the rewards split % of total rewards to esSteady\n  * @param _id  Unique id of farm\n  * @param _esSteadySplit  Rewards split % of total rewards to esSteady\n  */\n  function updateEsSteadySplit(uint256 _id, uint256 _esSteadySplit) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n    require(_esSteadySplit <= MAX_REWARDS_SPLIT, \"Reward split must be less maximum\");\n\n    farms[_id].esSteadySplit = _esSteadySplit;\n    _updateFarm(_id);\n\n    emit UpdateEsSteadySplit(_id, _esSteadySplit);\n  }\n\n  /**\n  * Update the max multiplier of a farm\n  * @param _id  Unique id of farm\n  * @param _maxMultiplier  Rewards split % of total rewards to esSteady\n  */\n  function updateMaxMultiplier(uint256 _id, uint256 _maxMultiplier) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n    require(_maxMultiplier >= SAFE_MULTIPLIER, \"Max multiplier must be greater than 1x\");\n\n    farms[_id].maxMultiplier = _maxMultiplier;\n    _updateFarm(_id);\n\n    emit UpdateMaxMultiplier(_id, _maxMultiplier);\n  }\n\n  /**\n  * Update the end time of a farm\n  * @param _id  Unique id of farm\n  * @param _endTime  Timestamp of end time for farm\n  */\n  function updateEndTime(uint256 _id, uint256 _endTime) external onlyOwner {\n    require(_id < totalFarms, \"Cannot update an unexisting farm\");\n    require(_endTime > block.timestamp, \"End time must be greater than current time\");\n\n    farms[_id].endTime = _endTime;\n    _updateFarm(_id);\n\n    emit UpdateEndTime(_id, _endTime);\n  }\n\n  /**\n  * Update yield booster plugin contract address\n  * @param _yieldBooster  Address of yield booster contract\n  */\n  function updateYieldBooster(address _yieldBooster) external onlyOwner {\n    yieldBooster = _yieldBooster;\n\n    emit UpdateYieldBooster(msg.sender, block.timestamp);\n  }\n\n  /**\n  * Update STEADY token manager contract address\n  * @param _tokenManager  Address of token manager contract\n  */\n  function updateTokenManager(address _tokenManager) external onlyOwner {\n    require(_tokenManager != address(0), \"invalid zero address\");\n\n    tokenManager = _tokenManager;\n\n    emit UpdateTokenManager(_tokenManager);\n  }\n\n  /**\n  * Pause farms contract\n  */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n  * Pause farms contract\n  */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n}\n```\n\nOLD END-TO-END TESTS:\n```\nfunction testOwnerCreateANewFarm() public {\n    vm.prank(owner);\n    farms.createFarm(\n        true,\n        address(steady),\n        1e17,\n        8e17,\n        25e17,\n        block.timestamp + 1000000\n    );\n\n    uint256 totalFarms = farms.totalFarms();\n\n    require(totalFarms == 1);\n}\n\nfunction testOwnerDepositRewardTokensToFarm() public {\n    vm.prank(owner);\n    farms.createFarm(\n        true,\n        address(steady),\n        1e17,\n        8e17,\n        25e17,\n        block.timestamp + 1000000\n    );\n\n    vm.prank(owner);\n    farms.depositRewardsTokens(0, 100000e18);\n\n    (, , , , , , , , uint256 totalRewards, , , ) = farms.farms(0);\n\n    require(totalRewards == 100000e18);\n}\n\nfunction testUserStakesTokensToFarm() public {\t\n    vm.prank(owner);\n    farms.createFarm(\n        true,\n        address(steady),\n        1e17,\n        8e17,\n        25e17,\n        block.timestamp + 1000000\n    );\n\n    vm.prank(owner);\n    farms.depositRewardsTokens(0, 100000e18);\n\n    vm.prank(user1);\n    farms.stake(0, 10e18);\n\n    (, , , , , , uint256 totalStaked, , , , , ) = farms.farms(0);    \n\n    require(totalStaked == 10e18);\n\n    (uint256 stakedAmount, , , ) = farms.positions(0, user1);\n\n    require(stakedAmount == 10e18);\n}\n```\n\nTEST CONTRACT CODE:\n```\n// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.17;\n\nimport {PTest, console} from \"@narya-ai/contracts/PTest.sol\";\nimport {STEADYbase} from \"../../../contracts/tokens/STEADYbase.sol\";\nimport {esSTEADY} from \"../../../contracts/tokens/esSTEADY.sol\";\nimport {TokenManager} from \"../../../contracts/tokens/TokenManager.sol\";\nimport {Farms} from \"../../../contracts/staking/Farms.sol\";\nimport {ISTEADY} from \"../../../contracts/interfaces/tokens/ISTEADY.sol\";\nimport {IesSTEADY} from \"../../../contracts/interfaces/tokens/IesSTEADY.sol\";\n\ncontract Farms_Test is PTest {\n    STEADYbase steady;\n    esSTEADY esSteady;\n    TokenManager tokenManager;\n    Farms farms;\n\n    address owner;\n    address user1;\n    address user2;\n    address lzEndPoint = 0x3c2269811836af69497E5F486A85D7316753cf62;\n\n    function setUp() public {\n        owner = makeAddr(\"Owner\");\n        user1 = makeAddr(\"User1\");\n        user2 = makeAddr(\"User2\");\n\n        vm.startPrank(owner);\n        steady = new STEADYbase(lzEndPoint);\n        esSteady = new esSTEADY();\n\n        tokenManager = new TokenManager(\n            ISTEADY(address(steady)),\n            IesSTEADY(address(esSteady))\n        );\n\n        esSteady.updateTokenManager(address(tokenManager));\n        esSteady.updateTransferWhitelist(address(tokenManager), true);\n\n        farms = new Farms(\n            address(steady),\n            address(tokenManager)\n        );\n\n        esSteady.updateTransferWhitelist(address(farms), true);\n        steady.approve(address(esSteady), type(uint256).max);\n        steady.approve(address(farms), type(uint256).max);\n        steady.transfer(user1, 1000e18);\n        steady.transfer(user2, 1000e18);\n        vm.stopPrank();\n\n        vm.startPrank(user1);\n        steady.approve(address(esSteady), type(uint256).max);\n        steady.approve(address(farms), type(uint256).max);\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        steady.approve(address(esSteady), type(uint256).max);\n        steady.approve(address(farms), type(uint256).max);\n        vm.stopPrank();\n    }\n\n    function testOwnerCreateANewFarm() public {\n        vm.startPrank(owner);\n        farms.createFarm(\n            true,\n            address(steady),\n            1e17, // rewardDistributionRate\n            8e17, // 0.8 = 80% esRewardSplit\n            25e17, // 2.5 = 2.5 x 1e18 maxMultiplier\n            block.timestamp + 1000000\n        );\n        require(farms.totalFarms() == 1, \"total number of farms is wrong\");\n    }\n\n    function testOwnerDepositRewardTokensToFarm() public {\n        _createNewFarm();\n        vm.startPrank(owner);\n        farms.depositRewardsTokens(0, 100000e18);\n\n        Farms.Farm memory farm0 = _getFarm(0);\n\n        require(farm0.totalRewards == 100000e18, \"Total number of rewards is wrong\");\n    }\n\n    function testUserStakesTokensToFarm() public {\n       _createNewFarm();\n       _ownerDepositsReward();\n\n\n        vm.startPrank(user1);\n        farms.stake(\n            0,\n            10e18\n        );\n        vm.stopPrank();\n\n        Farms.Farm memory farm0 = _getFarm(0);\n        Farms.Position memory positionUser1 = _getPosition(0, user1);\n\n        require(positionUser1.stakedAmount == 10e18, \"Staked amount for user1 is wrong\");\n        require(farm0.totalStaked == 10e18, \"Total staked is wrong\");\n\n    }\n\n    // INTERNAL FUNCTIONS\n    function _createNewFarm() internal {\n        vm.startPrank(owner);\n        farms.createFarm(\n            true,\n            address(steady),\n            1e17, // rewardDistributionRate\n            8e17, // 0.8 = 80% esRewardSplit\n            25e17, // 2.5 = 2.5 x 1e18 maxMultiplier\n            block.timestamp + 1000000\n        );\n        vm.stopPrank();\n    }\n\n    function _userStakesTokensToFarm() internal {\n        vm.startPrank(user1);\n        farms.stake(\n            0,\n            10e18\n        );\n        vm.stopPrank();\n    }\n\n    function _ownerDepositsReward() internal {\n        vm.startPrank(owner);\n        farms.depositRewardsTokens(0, 100000e18);\n        vm.stopPrank();\n    }\n\n    function _getFarm(uint256 _farmId) internal view returns(Farms.Farm memory){\n        Farms.Farm memory farm0;\n        ( , farm0.active, farm0.stakedToken, farm0.rewardsDistributionRate, farm0.rewardsPerStakedToken, , farm0.totalStaked, farm0.totalPoints, farm0.totalRewards, , , farm0.endTime ) = farms.farms(0);\n        return farm0;\n    }\n\n    function _getPosition(\n        uint256 _farmId,\n        address _user\n    ) internal view returns(Farms.Position memory){\n        Farms.Position memory positionUser1;\n        (positionUser1.stakedAmount, positionUser1.rewardsDebt, positionUser1.rewardsRedeemed, positionUser1.pointsAmount ) = farms.positions(_farmId, _user);\n        return positionUser1;\n    }\n}\n```\n\nFUNCTION TO BE TESTED:\nFarms.claim\n\nNEW END-TO-END TEST:\n```\n    function testUserShouldBeAbleToClaimSTEADYandEsSteady() public {\n        _createNewFarm();\n        _ownerDepositsReward();\n        _userStakesTokensToFarm();\n\n        skip(20);\n        vm.startPrank(user1);\n        farms.claim(0);\n\n        // Farms.Farm memory farm0 = _getFarm(0);\n        Farms.Position memory positionUser1 = _getPosition(0, user1);\n        console.log(\"rewards earned value for farms 0\");\n        console.log(farms.rewardsEarned(0, user1));\n        console.log(\"position for user 1\");\n        console.log(positionUser1.rewardsRedeemed);\n        console.log(\"STEADY balance for user1\");\n        console.log(steady.balanceOf(user1));\n        console.log(\"esSTEADY balance for user1\");\n        console.log(esSteady.balanceOf(user1));\n        require(farms.rewardsEarned(0, user1) == 0, \"Rewards Earned value is wrong\");\n        require(positionUser1.rewardsRedeemed == 2e18, \"Rewards Redeemed value is wrong\");\n        require(steady.balanceOf(user1) == 9904e17, \"Steady balance for user1 is wrong\");\n        require(esSteady.balanceOf(user1) == 16e17, \"esSteady balacne for user1 is wrong\");\n    }\n```", "user_task": "\nHere is the smart contract code to be tested: {contract_code}\nHere is the test contract in Solidity: {test_contract_code}\nHere is the specific function you need to test in the new end-to-end test: {function}\nRecommend a new end-to-end test wrapped in a Solidity function with no other comments or explanation."}